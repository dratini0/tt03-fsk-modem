/* Generated by Yosys 0.23 (git sha1 7ce5011c24b) */

module dratini0_fsk_modem_top(io_out, io_in);
  wire [5:0] \$1 ;
  wire [5:0] \$2 ;
  input [7:0] io_in;
  wire [7:0] io_in;
  output [7:0] io_out;
  wire [7:0] io_out;
  wire rx_clk;
  wire [9:0] rx_frequency;
  wire rx_frequency_invert;
  wire [4:0] rx_in_;
  wire rx_out;
  wire rx_rst;
  wire rx_valid;
  wire [9:0] wg1_frequency;
  wire [9:0] wg1_out;
  wire [9:0] wg2_frequency;
  wire [9:0] wg2_out;
  assign \$2  = wg1_out[9:5] + wg2_out[9:5];
  rx rx (
    .clk(rx_clk),
    .frequency(10'h08f),
    .frequency_invert(1'h0),
    .in_(rx_in_),
    .out(rx_out),
    .rst(rx_rst),
    .valid(rx_valid)
  );
  wg1 wg1 (
    .clk(rx_clk),
    .frequency(10'h03f),
    .out(wg1_out),
    .rst(rx_rst)
  );
  wg2 wg2 (
    .clk(rx_clk),
    .frequency(10'h06d),
    .out(wg2_out),
    .rst(rx_rst)
  );
  assign \$1  = \$2 ;
  assign io_out[7:3] = \$2 [5:1];
  assign io_out[1] = rx_valid;
  assign io_out[0] = rx_out;
  assign io_out[2] = 1'h0;
  assign rx_in_ = io_in[7:3];
  assign rx_frequency_invert = 1'h0;
  assign wg2_frequency = 10'h06d;
  assign wg1_frequency = 10'h03f;
  assign rx_frequency = 10'h08f;
  assign rx_rst = io_in[1];
  assign rx_clk = io_in[0];
endmodule

module i_filter(rst, in_, out, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$1  = 0;
  wire [14:0] \$1 ;
  wire [14:0] \$10 ;
  wire [19:0] \$12 ;
  wire [7:0] \$13 ;
  wire [7:0] \$15 ;
  wire [8:0] \$17 ;
  wire [16:0] \$19 ;
  wire [11:0] \$2 ;
  wire [16:0] \$21 ;
  wire [17:0] \$23 ;
  wire [15:0] \$25 ;
  wire [15:0] \$27 ;
  wire [18:0] \$29 ;
  wire [19:0] \$31 ;
  wire [19:0] \$33 ;
  wire [12:0] \$4 ;
  wire [13:0] \$6 ;
  wire [14:0] \$8 ;
  input clk;
  wire clk;
  input [4:0] in_;
  wire [4:0] in_;
  output [10:0] out;
  wire [10:0] out;
  input rst;
  wire rst;
  wire [10:0] v_0;
  reg [10:0] v_1 = 11'h000;
  reg [10:0] \v_1$next ;
  reg [10:0] v_2 = 11'h000;
  reg [10:0] \v_2$next ;
  assign \$17  = $signed(\$13 ) + $signed(\$15 );
  assign \$19  = $signed(11'h039) * $signed(v_1);
  assign \$23  = $signed(\$17 ) + $signed(\$21 );
  assign \$25  = $signed(11'h01a) * $signed(v_2);
  assign \$29  = $signed(\$23 ) - $signed(\$27 );
  assign \$31  = $signed(\$29 ) + $signed(19'h00004);
  always @(posedge clk)
    v_1 <= \v_1$next ;
  always @(posedge clk)
    v_2 <= \v_2$next ;
  assign \$4  = $signed(v_0) + $signed(\$2 );
  assign \$6  = $signed(\$4 ) + $signed(v_2);
  assign \$8  = $signed(\$6 ) + $signed(14'h0001);
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    \v_1$next  = v_0;
    casez (rst)
      1'h1:
          \v_1$next  = 11'h000;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    \v_2$next  = v_1;
    casez (rst)
      1'h1:
          \v_2$next  = 11'h000;
    endcase
  end
  assign \$1  = \$10 ;
  assign \$12  = \$33 ;
  assign v_0 = \$33 [10:0];
  assign out = \$10 [10:0];
  assign \$2  = { v_1, 1'h0 };
  assign \$13  = { in_, 3'h0 };
  assign \$15  = { in_[4], in_, 2'h0 };
  assign \$21  = { \$19 [16], \$19 [16], \$19 [16:2] };
  assign \$27  = { \$25 [15], \$25 [15], \$25 [15:2] };
  assign \$33  = { \$31 [19], \$31 [19], \$31 [19], \$31 [19:3] };
  assign \$10  = { \$8 [14], \$8 [14], \$8 [14:2] };
endmodule

module lut(out, in_);
  reg \$auto$verilog_backend.cc:2083:dump_module$2  = 0;
  wire \$1 ;
  wire [9:0] \$3 ;
  wire [9:0] \$5 ;
  wire [9:0] \$6 ;
  input [9:0] in_;
  wire [9:0] in_;
  output [9:0] out;
  reg [9:0] out;
  assign \$1  = ~ in_[9];
  assign \$5  = ~ \$6 ;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    (* full_case = 32'd1 *)
    casez (\$1 )
      1'h1:
          out = \$3 ;
      default:
          out = \$5 ;
    endcase
  end
  assign \$3  = { in_[8:0], 1'h0 };
  assign \$6  = { in_[8:0], 1'h0 };
endmodule

module \lut$1 (out, in_);
  reg \$auto$verilog_backend.cc:2083:dump_module$3  = 0;
  wire \$1 ;
  wire [9:0] \$3 ;
  wire [9:0] \$5 ;
  wire [9:0] \$6 ;
  input [9:0] in_;
  wire [9:0] in_;
  output [9:0] out;
  reg [9:0] out;
  assign \$1  = ~ in_[9];
  assign \$5  = ~ \$6 ;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    (* full_case = 32'd1 *)
    casez (\$1 )
      1'h1:
          out = \$3 ;
      default:
          out = \$5 ;
    endcase
  end
  assign \$3  = { in_[8:0], 1'h0 };
  assign \$6  = { in_[8:0], 1'h0 };
endmodule

module mixer(rst, in_, frequency, i, q, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$4  = 0;
  wire [10:0] \$1 ;
  wire [4:0] \$10 ;
  wire [10:0] \$2 ;
  wire [4:0] \$4 ;
  wire [4:0] \$6 ;
  wire [4:0] \$8 ;
  reg [9:0] _phase = 10'h000;
  wire [9:0] \_phase$next ;
  input clk;
  wire clk;
  input [9:0] frequency;
  wire [9:0] frequency;
  output [4:0] i;
  reg [4:0] i;
  input [4:0] in_;
  wire [4:0] in_;
  output [4:0] q;
  reg [4:0] q;
  input rst;
  wire rst;
  assign \$10  = ~ $signed(in_);
  always @(posedge clk)
    _phase <= \_phase$next ;
  assign \$2  = _phase + frequency;
  assign \$4  = ~ $signed(in_);
  assign \$6  = ~ $signed(in_);
  assign \$8  = ~ $signed(in_);
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$4 ) begin end
    (* full_case = 32'd1 *)
    casez (_phase[9:8])
      2'h0:
          i = in_;
      2'h1:
          i = in_;
      2'h2:
          i = \$4 ;
      2'h3:
          i = \$6 ;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$4 ) begin end
    (* full_case = 32'd1 *)
    casez (_phase[9:8])
      2'h0:
          q = in_;
      2'h1:
          q = \$8 ;
      2'h2:
          q = \$10 ;
      2'h3:
          q = in_;
    endcase
  end
  assign \$1  = \$2 ;
  assign \_phase$next  = \$2 [9:0];
endmodule

module phase_detector(q, phase, i);
  reg \$auto$verilog_backend.cc:2083:dump_module$5  = 0;
  wire [10:0] \$1 ;
  wire \$10 ;
  wire \$13 ;
  wire \$15 ;
  wire \$17 ;
  wire [10:0] \$3 ;
  wire \$4 ;
  wire [10:0] \$7 ;
  wire [10:0] \$9 ;
  input [10:0] i;
  wire [10:0] i;
  output [2:0] phase;
  reg [2:0] phase;
  input [10:0] q;
  wire [10:0] q;
  assign \$10  = $signed(q) >= $signed(11'h000);
  assign \$9  = \$10  ? q : \$7 ;
  assign \$13  = $signed(\$3 ) > $signed(\$9 );
  assign \$15  = $signed(i) >= $signed(11'h000);
  assign \$17  = $signed(q) >= $signed(11'h000);
  assign \$1  = ~ $signed(i);
  assign \$4  = $signed(i) >= $signed(11'h000);
  assign \$3  = \$4  ? i : \$1 ;
  assign \$7  = ~ $signed(q);
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$5 ) begin end
    (* full_case = 32'd1 *)
    casez ({ \$17 , \$15 , \$13  })
      3'h7:
          phase = 3'h0;
      3'h6:
          phase = 3'h1;
      3'h4:
          phase = 3'h2;
      3'h5:
          phase = 3'h3;
      3'h1:
          phase = 3'h4;
      3'h0:
          phase = 3'h5;
      3'h2:
          phase = 3'h6;
      3'h3:
          phase = 3'h7;
    endcase
  end
endmodule

module phase_differentiator(rst, phase, out, valid, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$6  = 0;
  wire \$1 ;
  wire \$10 ;
  wire [10:0] \$12 ;
  wire [3:0] \$3 ;
  wire [3:0] \$4 ;
  wire [3:0] \$6 ;
  wire [3:0] \$7 ;
  wire [10:0] \$9 ;
  reg [2:0] _last_phase = 3'h0;
  wire [2:0] \_last_phase$next ;
  reg [9:0] _valid_counter = 10'h000;
  reg [9:0] \_valid_counter$next ;
  reg _valid_counter_reset;
  input clk;
  wire clk;
  output out;
  reg out = 1'h0;
  reg \out$next ;
  input [2:0] phase;
  wire [2:0] phase;
  input rst;
  wire rst;
  output valid;
  wire valid;
  assign \$10  = ~ valid;
  assign \$12  = _valid_counter + \$10 ;
  always @(posedge clk)
    _last_phase <= \_last_phase$next ;
  always @(posedge clk)
    out <= \out$next ;
  always @(posedge clk)
    _valid_counter <= \_valid_counter$next ;
  assign \$1  = _valid_counter == 10'h3ff;
  assign \$4  = phase - _last_phase;
  assign \$7  = phase - _last_phase;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$6 ) begin end
    (* full_case = 32'd1 *)
    casez (\$3 [2:0])
      3'h0:
          _valid_counter_reset = 1'h0;
      3'h7:
          _valid_counter_reset = 1'h0;
      3'h1:
          _valid_counter_reset = 1'h0;
      default:
          _valid_counter_reset = 1'h1;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$6 ) begin end
    \out$next  = out;
    casez (\$6 [2:0])
      3'h0:
          /* empty */;
      3'h7:
          \out$next  = 1'h1;
      3'h1:
          \out$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$6 ) begin end
    (* full_case = 32'd1 *)
    casez (_valid_counter_reset)
      1'h1:
          \_valid_counter$next  = 10'h000;
      default:
          \_valid_counter$next  = \$12 [9:0];
    endcase
  end
  assign \$3  = \$4 ;
  assign \$6  = \$7 ;
  assign \$9  = \$12 ;
  assign \_last_phase$next  = phase;
  assign valid = \$1 ;
endmodule

module q_filter(rst, in_, out, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$7  = 0;
  wire [14:0] \$1 ;
  wire [14:0] \$10 ;
  wire [19:0] \$12 ;
  wire [7:0] \$13 ;
  wire [7:0] \$15 ;
  wire [8:0] \$17 ;
  wire [16:0] \$19 ;
  wire [11:0] \$2 ;
  wire [16:0] \$21 ;
  wire [17:0] \$23 ;
  wire [15:0] \$25 ;
  wire [15:0] \$27 ;
  wire [18:0] \$29 ;
  wire [19:0] \$31 ;
  wire [19:0] \$33 ;
  wire [12:0] \$4 ;
  wire [13:0] \$6 ;
  wire [14:0] \$8 ;
  input clk;
  wire clk;
  input [4:0] in_;
  wire [4:0] in_;
  output [10:0] out;
  wire [10:0] out;
  input rst;
  wire rst;
  wire [10:0] v_0;
  reg [10:0] v_1 = 11'h000;
  reg [10:0] \v_1$next ;
  reg [10:0] v_2 = 11'h000;
  reg [10:0] \v_2$next ;
  assign \$17  = $signed(\$13 ) + $signed(\$15 );
  assign \$19  = $signed(11'h039) * $signed(v_1);
  assign \$23  = $signed(\$17 ) + $signed(\$21 );
  assign \$25  = $signed(11'h01a) * $signed(v_2);
  assign \$29  = $signed(\$23 ) - $signed(\$27 );
  assign \$31  = $signed(\$29 ) + $signed(19'h00004);
  always @(posedge clk)
    v_1 <= \v_1$next ;
  always @(posedge clk)
    v_2 <= \v_2$next ;
  assign \$4  = $signed(v_0) + $signed(\$2 );
  assign \$6  = $signed(\$4 ) + $signed(v_2);
  assign \$8  = $signed(\$6 ) + $signed(14'h0001);
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \v_1$next  = v_0;
    casez (rst)
      1'h1:
          \v_1$next  = 11'h000;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \v_2$next  = v_1;
    casez (rst)
      1'h1:
          \v_2$next  = 11'h000;
    endcase
  end
  assign \$1  = \$10 ;
  assign \$12  = \$33 ;
  assign v_0 = \$33 [10:0];
  assign out = \$10 [10:0];
  assign \$2  = { v_1, 1'h0 };
  assign \$13  = { in_, 3'h0 };
  assign \$15  = { in_[4], in_, 2'h0 };
  assign \$21  = { \$19 [16], \$19 [16], \$19 [16:2] };
  assign \$27  = { \$25 [15], \$25 [15], \$25 [15:2] };
  assign \$33  = { \$31 [19], \$31 [19], \$31 [19], \$31 [19:3] };
  assign \$10  = { \$8 [14], \$8 [14], \$8 [14:2] };
endmodule

module rx(rst, frequency, frequency_invert, in_, out, valid, clk);
  wire \$1 ;
  input clk;
  wire clk;
  input [9:0] frequency;
  wire [9:0] frequency;
  input frequency_invert;
  wire frequency_invert;
  wire [4:0] i_filter_in_;
  wire [10:0] i_filter_out;
  input [4:0] in_;
  wire [4:0] in_;
  wire [9:0] mixer_frequency;
  wire [4:0] mixer_i;
  wire [4:0] mixer_in_;
  wire [4:0] mixer_q;
  output out;
  wire out;
  wire [10:0] phase_detector_i;
  wire [2:0] phase_detector_phase;
  wire [10:0] phase_detector_q;
  wire phase_differentiator_out;
  wire [2:0] phase_differentiator_phase;
  wire phase_differentiator_valid;
  wire [4:0] q_filter_in_;
  wire [10:0] q_filter_out;
  input rst;
  wire rst;
  output valid;
  wire valid;
  assign \$1  = phase_differentiator_out ^ frequency_invert;
  i_filter i_filter (
    .clk(clk),
    .in_(i_filter_in_),
    .out(i_filter_out),
    .rst(rst)
  );
  mixer mixer (
    .clk(clk),
    .frequency(mixer_frequency),
    .i(mixer_i),
    .in_(mixer_in_),
    .q(mixer_q),
    .rst(rst)
  );
  phase_detector phase_detector (
    .i(phase_detector_i),
    .phase(phase_detector_phase),
    .q(phase_detector_q)
  );
  phase_differentiator phase_differentiator (
    .clk(clk),
    .out(phase_differentiator_out),
    .phase(phase_differentiator_phase),
    .rst(rst),
    .valid(phase_differentiator_valid)
  );
  q_filter q_filter (
    .clk(clk),
    .in_(q_filter_in_),
    .out(q_filter_out),
    .rst(rst)
  );
  assign valid = phase_differentiator_valid;
  assign out = \$1 ;
  assign phase_differentiator_phase = phase_detector_phase;
  assign phase_detector_q = q_filter_out;
  assign phase_detector_i = i_filter_out;
  assign q_filter_in_ = mixer_q;
  assign i_filter_in_ = mixer_i;
  assign mixer_frequency = frequency;
  assign mixer_in_ = in_;
endmodule

module wg1(rst, frequency, out, clk);
  wire [10:0] \$1 ;
  wire [10:0] \$2 ;
  reg [9:0] _state = 10'h000;
  wire [9:0] \_state$next ;
  input clk;
  wire clk;
  input [9:0] frequency;
  wire [9:0] frequency;
  wire [9:0] lut_in_;
  wire [9:0] lut_out;
  output [9:0] out;
  wire [9:0] out;
  input rst;
  wire rst;
  assign \$2  = _state + frequency;
  always @(posedge clk)
    _state <= \_state$next ;
  lut lut (
    .in_(lut_in_),
    .out(lut_out)
  );
  assign \$1  = \$2 ;
  assign \_state$next  = \$2 [9:0];
  assign out = lut_out;
  assign lut_in_ = _state;
endmodule

module wg2(rst, frequency, out, clk);
  wire [10:0] \$1 ;
  wire [10:0] \$2 ;
  reg [9:0] _state = 10'h000;
  wire [9:0] \_state$next ;
  input clk;
  wire clk;
  input [9:0] frequency;
  wire [9:0] frequency;
  wire [9:0] lut_in_;
  wire [9:0] lut_out;
  output [9:0] out;
  wire [9:0] out;
  input rst;
  wire rst;
  assign \$2  = _state + frequency;
  always @(posedge clk)
    _state <= \_state$next ;
  \lut$1  lut (
    .in_(lut_in_),
    .out(lut_out)
  );
  assign \$1  = \$2 ;
  assign \_state$next  = \$2 [9:0];
  assign out = lut_out;
  assign lut_in_ = _state;
endmodule

