/* Generated by Yosys 0.23 (git sha1 7ce5011c24b) */

module dratini0_fsk_modem_top(io_out, io_in);
  wire fsk_modem_clk;
  wire fsk_modem_cs_n;
  wire fsk_modem_data_in;
  wire fsk_modem_data_out;
  wire fsk_modem_mosi;
  wire fsk_modem_rst;
  wire fsk_modem_samples_in;
  wire [5:0] fsk_modem_samples_out;
  wire fsk_modem_sck;
  wire fsk_modem_valid_out;
  input [7:0] io_in;
  wire [7:0] io_in;
  output [7:0] io_out;
  wire [7:0] io_out;
  fsk_modem fsk_modem (
    .clk(fsk_modem_clk),
    .cs_n(fsk_modem_cs_n),
    .data_in(fsk_modem_data_in),
    .data_out(fsk_modem_data_out),
    .mosi(fsk_modem_mosi),
    .rst(fsk_modem_rst),
    .samples_in(fsk_modem_samples_in),
    .samples_out(fsk_modem_samples_out),
    .sck(fsk_modem_sck),
    .valid_out(fsk_modem_valid_out)
  );
  assign io_out[7:2] = fsk_modem_samples_out;
  assign io_out[1] = fsk_modem_valid_out;
  assign io_out[0] = fsk_modem_data_out;
  assign fsk_modem_samples_in = io_in[7];
  assign fsk_modem_data_in = io_in[5];
  assign fsk_modem_mosi = io_in[4];
  assign fsk_modem_sck = io_in[3];
  assign fsk_modem_cs_n = io_in[2];
  assign fsk_modem_rst = io_in[1];
  assign fsk_modem_clk = io_in[0];
endmodule

module \edge (rst, in_, out, clk);
  wire \$1 ;
  wire \$3 ;
  input clk;
  wire clk;
  input in_;
  wire in_;
  reg last_in = 1'h0;
  wire \last_in$next ;
  output out;
  wire out;
  input rst;
  wire rst;
  assign \$1  = ~ last_in;
  assign \$3  = in_ & \$1 ;
  always @(posedge clk)
    last_in <= \last_in$next ;
  assign out = \$3 ;
  assign \last_in$next  = in_;
endmodule

module fsk_modem(rst, cs_n, sck, mosi, data_in, samples_in, data_out, valid_out, samples_out, clk);
  wire [7:0] \$1 ;
  wire \$11 ;
  wire \$13 ;
  wire \$15 ;
  wire \$17 ;
  wire \$19 ;
  wire [9:0] \$21 ;
  wire [3:0] \$23 ;
  wire \$25 ;
  wire [9:0] \$3 ;
  wire [7:0] \$4 ;
  wire [9:0] \$7 ;
  wire [9:0] \$9 ;
  wire _validity_enforced;
  input clk;
  wire clk;
  input cs_n;
  wire cs_n;
  input data_in;
  wire data_in;
  output data_out;
  wire data_out;
  input mosi;
  wire mosi;
  wire [7:0] registers_data_in;
  wire registers_enable_retimer;
  wire registers_enforce_validity;
  wire registers_frequency_invert;
  wire [7:0] registers_mixer_freq;
  wire [7:0] registers_retimer_freq;
  wire [1:0] registers_retimer_width;
  wire [7:0] registers_we;
  wire [7:0] registers_wg1_freq_mark;
  wire [7:0] registers_wg1_freq_space;
  wire [7:0] registers_wg2_freq;
  wire [1:0] registers_wg_mux_cfg;
  wire [7:0] retimer_rx_data;
  wire [9:0] retimer_rx_frequency;
  wire retimer_rx_in_;
  wire retimer_rx_we;
  wire [3:0] retimer_rx_width;
  wire [7:0] retimer_tx_data;
  wire [9:0] retimer_tx_frequency;
  wire retimer_tx_out;
  wire retimer_tx_we;
  input rst;
  wire rst;
  wire [9:0] rx_frequency;
  wire rx_frequency_invert;
  wire rx_in_;
  wire rx_out;
  wire rx_valid;
  input samples_in;
  wire samples_in;
  output [5:0] samples_out;
  wire [5:0] samples_out;
  input sck;
  wire sck;
  wire spi_cs_n;
  wire [7:0] spi_data;
  wire spi_mosi;
  wire spi_sck;
  wire spi_we;
  output valid_out;
  wire valid_out;
  wire [9:0] wg1_frequency;
  wire [9:0] wg1_out;
  wire [9:0] wg2_frequency;
  wire [9:0] wg2_out;
  wire [1:0] wgmux_cfg;
  wire [5:0] wgmux_in1;
  wire [5:0] wgmux_in2;
  wire [5:0] wgmux_out;
  assign \$9  = + registers_mixer_freq;
  assign \$11  = ~ rx_valid;
  assign \$13  = registers_enforce_validity & \$11 ;
  assign \$15  = rx_out | \$13 ;
  assign \$17  = ~ registers_enable_retimer;
  assign \$1  = + spi_we;
  assign \$19  = _validity_enforced | \$17 ;
  assign \$21  = + registers_retimer_freq;
  assign \$23  = registers_retimer_width + 3'h5;
  assign \$25  = registers_enable_retimer ? retimer_tx_out : _validity_enforced;
  assign \$4  = data_in ? registers_wg1_freq_mark : registers_wg1_freq_space;
  assign \$3  = + \$4 ;
  assign \$7  = + registers_wg2_freq;
  registers registers (
    .clk(clk),
    .data_in(registers_data_in),
    .enable_retimer(registers_enable_retimer),
    .enforce_validity(registers_enforce_validity),
    .frequency_invert(registers_frequency_invert),
    .mixer_freq(registers_mixer_freq),
    .retimer_freq(registers_retimer_freq),
    .retimer_width(registers_retimer_width),
    .rst(rst),
    .we(registers_we),
    .wg1_freq_mark(registers_wg1_freq_mark),
    .wg1_freq_space(registers_wg1_freq_space),
    .wg2_freq(registers_wg2_freq),
    .wg_mux_cfg(registers_wg_mux_cfg)
  );
  retimer_rx retimer_rx (
    .clk(clk),
    .data(retimer_rx_data),
    .frequency(retimer_rx_frequency),
    .in_(retimer_rx_in_),
    .rst(rst),
    .we(retimer_rx_we),
    .width(retimer_rx_width)
  );
  retimer_tx retimer_tx (
    .clk(clk),
    .data(retimer_tx_data),
    .frequency(10'h062),
    .out(retimer_tx_out),
    .rst(rst),
    .we(retimer_tx_we)
  );
  rx rx (
    .clk(clk),
    .frequency(rx_frequency),
    .frequency_invert(rx_frequency_invert),
    .in_(rx_in_),
    .out(rx_out),
    .rst(rst),
    .valid(rx_valid)
  );
  spi spi (
    .clk(clk),
    .cs_n(spi_cs_n),
    .data(spi_data),
    .mosi(spi_mosi),
    .rst(rst),
    .sck(spi_sck),
    .we(spi_we)
  );
  wg1 wg1 (
    .clk(clk),
    .frequency(wg1_frequency),
    .out(wg1_out),
    .rst(rst)
  );
  wg2 wg2 (
    .clk(clk),
    .frequency(wg2_frequency),
    .out(wg2_out),
    .rst(rst)
  );
  wgmux wgmux (
    .cfg(wgmux_cfg),
    .in1(wgmux_in1),
    .in2(wgmux_in2),
    .out(wgmux_out)
  );
  assign valid_out = rx_valid;
  assign data_out = \$25 ;
  assign retimer_tx_frequency = 10'h062;
  assign retimer_tx_we = retimer_rx_we;
  assign retimer_tx_data = retimer_rx_data;
  assign retimer_rx_width = \$23 ;
  assign retimer_rx_frequency = \$21 ;
  assign retimer_rx_in_ = \$19 ;
  assign _validity_enforced = \$15 ;
  assign rx_frequency_invert = registers_frequency_invert;
  assign rx_frequency = \$9 ;
  assign rx_in_ = samples_in;
  assign samples_out = wgmux_out;
  assign wgmux_cfg = registers_wg_mux_cfg;
  assign wgmux_in2 = wg2_out[9:4];
  assign wgmux_in1 = wg1_out[9:4];
  assign wg2_frequency = \$7 ;
  assign wg1_frequency = \$3 ;
  assign registers_we = \$1 ;
  assign registers_data_in = spi_data;
  assign spi_mosi = mosi;
  assign spi_sck = sck;
  assign spi_cs_n = cs_n;
endmodule

module glitch_filter(rst, in_, out, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$1  = 0;
  wire \$1 ;
  wire \$10 ;
  wire \$3 ;
  wire [2:0] \$5 ;
  wire [2:0] \$6 ;
  wire \$8 ;
  reg [1:0] _count = 2'h0;
  reg [1:0] \_count$next ;
  input clk;
  wire clk;
  input in_;
  wire in_;
  output out;
  reg out = 1'h0;
  reg \out$next ;
  input rst;
  wire rst;
  assign \$10  = _count == 2'h3;
  always @(posedge clk)
    _count <= \_count$next ;
  always @(posedge clk)
    out <= \out$next ;
  assign \$1  = in_ == out;
  assign \$3  = _count == 2'h3;
  assign \$6  = _count + 1'h1;
  assign \$8  = in_ == out;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    (* full_case = 32'd1 *)
    casez ({ \$3 , \$1  })
      2'b?1:
          \_count$next  = 2'h0;
      2'b1?:
          \_count$next  = 2'h0;
      default:
          \_count$next  = \$6 [1:0];
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$1 ) begin end
    \out$next  = out;
    casez ({ \$10 , \$8  })
      2'b?1:
          /* empty */;
      2'b1?:
          \out$next  = in_;
    endcase
  end
  assign \$5  = \$6 ;
endmodule

module i_filter(rst, in_, out, clk);
  wire [31:0] \$1 ;
  wire [3:0] \$10 ;
  wire [26:0] \$100 ;
  wire [3:0] \$102 ;
  wire [27:0] \$104 ;
  wire [3:0] \$106 ;
  wire [28:0] \$108 ;
  wire [1:0] \$110 ;
  wire [29:0] \$112 ;
  wire [1:0] \$114 ;
  wire [30:0] \$116 ;
  wire [1:0] \$118 ;
  wire [4:0] \$12 ;
  wire [31:0] \$120 ;
  wire [3:0] \$14 ;
  wire [5:0] \$16 ;
  wire [3:0] \$18 ;
  wire [1:0] \$2 ;
  wire [6:0] \$20 ;
  wire [3:0] \$22 ;
  wire [7:0] \$24 ;
  wire [7:0] \$26 ;
  wire [8:0] \$28 ;
  wire [7:0] \$30 ;
  wire [9:0] \$32 ;
  wire [7:0] \$34 ;
  wire [10:0] \$36 ;
  wire [7:0] \$38 ;
  wire [2:0] \$4 ;
  wire [11:0] \$40 ;
  wire [7:0] \$42 ;
  wire [12:0] \$44 ;
  wire [7:0] \$46 ;
  wire [13:0] \$48 ;
  wire [7:0] \$50 ;
  wire [14:0] \$52 ;
  wire [7:0] \$54 ;
  wire [15:0] \$56 ;
  wire [7:0] \$58 ;
  wire [1:0] \$6 ;
  wire [16:0] \$60 ;
  wire [7:0] \$62 ;
  wire [17:0] \$64 ;
  wire [7:0] \$66 ;
  wire [18:0] \$68 ;
  wire [7:0] \$70 ;
  wire [19:0] \$72 ;
  wire [7:0] \$74 ;
  wire [20:0] \$76 ;
  wire [7:0] \$78 ;
  wire [3:0] \$8 ;
  wire [21:0] \$80 ;
  wire [7:0] \$82 ;
  wire [22:0] \$84 ;
  wire [7:0] \$86 ;
  wire [23:0] \$88 ;
  wire [7:0] \$90 ;
  wire [24:0] \$92 ;
  wire [3:0] \$94 ;
  wire [25:0] \$96 ;
  wire [3:0] \$98 ;
  reg [29:0] _x = 30'h00000000;
  wire [29:0] \_x$next ;
  input clk;
  wire clk;
  input in_;
  wire in_;
  output [8:0] out;
  wire [8:0] out;
  input rst;
  wire rst;
  assign \$100  = \$96  + \$98 ;
  assign \$104  = \$100  + \$102 ;
  assign \$108  = \$104  + \$106 ;
  assign \$112  = \$108  + \$110 ;
  assign \$116  = \$112  + \$114 ;
  assign \$120  = \$116  + \$118 ;
  always @(posedge clk)
    _x <= \_x$next ;
  assign \$12  = \$8  + \$10 ;
  assign \$16  = \$12  + \$14 ;
  assign \$20  = \$16  + \$18 ;
  assign \$24  = \$20  + \$22 ;
  assign \$28  = \$24  + \$26 ;
  assign \$32  = \$28  + \$30 ;
  assign \$36  = \$32  + \$34 ;
  assign \$40  = \$36  + \$38 ;
  assign \$44  = \$40  + \$42 ;
  assign \$48  = \$44  + \$46 ;
  assign \$4  = in_ + \$2 ;
  assign \$52  = \$48  + \$50 ;
  assign \$56  = \$52  + \$54 ;
  assign \$60  = \$56  + \$58 ;
  assign \$64  = \$60  + \$62 ;
  assign \$68  = \$64  + \$66 ;
  assign \$72  = \$68  + \$70 ;
  assign \$76  = \$72  + \$74 ;
  assign \$80  = \$76  + \$78 ;
  assign \$84  = \$80  + \$82 ;
  assign \$88  = \$84  + \$86 ;
  assign \$8  = \$4  + \$6 ;
  assign \$92  = \$88  + \$90 ;
  assign \$96  = \$92  + \$94 ;
  assign \$1  = \$120 ;
  assign out = \$120 [8:0];
  assign \_x$next [29:1] = _x[28:0];
  assign \_x$next [0] = in_;
  assign \$2  = { 1'h0, _x[0] };
  assign \$6  = { _x[1], 1'h0 };
  assign \$10  = { 1'h0, _x[2], 2'h0 };
  assign \$14  = { 1'h0, _x[3], 2'h0 };
  assign \$18  = { _x[4], 3'h0 };
  assign \$22  = { _x[5], 3'h0 };
  assign \$26  = { 3'h0, _x[6], 4'h0 };
  assign \$30  = { 3'h0, _x[7], 4'h0 };
  assign \$34  = { 3'h0, _x[8], 4'h0 };
  assign \$38  = { 2'h0, _x[9], 5'h00 };
  assign \$42  = { 2'h0, _x[10], 5'h00 };
  assign \$46  = { 2'h0, _x[11], 5'h00 };
  assign \$50  = { 2'h0, _x[12], 5'h00 };
  assign \$54  = { 2'h0, _x[13], 5'h00 };
  assign \$58  = { 2'h0, _x[14], 5'h00 };
  assign \$62  = { 2'h0, _x[15], 5'h00 };
  assign \$66  = { 2'h0, _x[16], 5'h00 };
  assign \$70  = { 2'h0, _x[17], 5'h00 };
  assign \$74  = { 2'h0, _x[18], 5'h00 };
  assign \$78  = { 2'h0, _x[19], 5'h00 };
  assign \$82  = { 3'h0, _x[20], 4'h0 };
  assign \$86  = { 3'h0, _x[21], 4'h0 };
  assign \$90  = { 3'h0, _x[22], 4'h0 };
  assign \$94  = { _x[23], 3'h0 };
  assign \$98  = { _x[24], 3'h0 };
  assign \$102  = { 1'h0, _x[25], 2'h0 };
  assign \$106  = { 1'h0, _x[26], 2'h0 };
  assign \$110  = { _x[27], 1'h0 };
  assign \$114  = { 1'h0, _x[28] };
  assign \$118  = { 1'h0, _x[29] };
endmodule

module lut(out, in_);
  reg \$auto$verilog_backend.cc:2083:dump_module$2  = 0;
  wire \$1 ;
  wire [9:0] \$3 ;
  wire [9:0] \$5 ;
  wire [9:0] \$6 ;
  input [9:0] in_;
  wire [9:0] in_;
  output [9:0] out;
  reg [9:0] out;
  assign \$1  = ~ in_[9];
  assign \$5  = ~ \$6 ;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$2 ) begin end
    (* full_case = 32'd1 *)
    casez (\$1 )
      1'h1:
          out = \$3 ;
      default:
          out = \$5 ;
    endcase
  end
  assign \$3  = { in_[8:0], 1'h0 };
  assign \$6  = { in_[8:0], 1'h0 };
endmodule

module \lut$1 (out, in_);
  reg \$auto$verilog_backend.cc:2083:dump_module$3  = 0;
  wire \$1 ;
  wire [9:0] \$3 ;
  wire [9:0] \$5 ;
  wire [9:0] \$6 ;
  input [9:0] in_;
  wire [9:0] in_;
  output [9:0] out;
  reg [9:0] out;
  assign \$1  = ~ in_[9];
  assign \$5  = ~ \$6 ;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$3 ) begin end
    (* full_case = 32'd1 *)
    casez (\$1 )
      1'h1:
          out = \$3 ;
      default:
          out = \$5 ;
    endcase
  end
  assign \$3  = { in_[8:0], 1'h0 };
  assign \$6  = { in_[8:0], 1'h0 };
endmodule

module mixer(rst, in_, frequency, i, q, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$4  = 0;
  wire [10:0] \$1 ;
  wire \$10 ;
  wire [10:0] \$2 ;
  wire \$4 ;
  wire \$6 ;
  wire \$8 ;
  reg [9:0] _phase = 10'h000;
  wire [9:0] \_phase$next ;
  input clk;
  wire clk;
  input [9:0] frequency;
  wire [9:0] frequency;
  output i;
  reg i;
  input in_;
  wire in_;
  output q;
  reg q;
  input rst;
  wire rst;
  assign \$10  = ~ $signed(in_);
  always @(posedge clk)
    _phase <= \_phase$next ;
  assign \$2  = _phase + frequency;
  assign \$4  = ~ $signed(in_);
  assign \$6  = ~ $signed(in_);
  assign \$8  = ~ $signed(in_);
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$4 ) begin end
    (* full_case = 32'd1 *)
    casez (_phase[9:8])
      2'h0:
          i = in_;
      2'h1:
          i = in_;
      2'h2:
          i = \$4 ;
      2'h3:
          i = \$6 ;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$4 ) begin end
    (* full_case = 32'd1 *)
    casez (_phase[9:8])
      2'h0:
          q = in_;
      2'h1:
          q = \$8 ;
      2'h2:
          q = \$10 ;
      2'h3:
          q = in_;
    endcase
  end
  assign \$1  = \$2 ;
  assign \_phase$next  = \$2 [9:0];
endmodule

module phase_detector(q, phase, i);
  reg \$auto$verilog_backend.cc:2083:dump_module$5  = 0;
  wire [9:0] \$1 ;
  wire \$10 ;
  wire \$13 ;
  wire \$15 ;
  wire \$17 ;
  wire [9:0] \$3 ;
  wire \$4 ;
  wire [9:0] \$7 ;
  wire [9:0] \$9 ;
  input [9:0] i;
  wire [9:0] i;
  output [2:0] phase;
  reg [2:0] phase;
  input [9:0] q;
  wire [9:0] q;
  assign \$10  = $signed(q) >= $signed(10'h000);
  assign \$9  = \$10  ? q : \$7 ;
  assign \$13  = $signed(\$3 ) > $signed(\$9 );
  assign \$15  = $signed(i) >= $signed(10'h000);
  assign \$17  = $signed(q) >= $signed(10'h000);
  assign \$1  = ~ $signed(i);
  assign \$4  = $signed(i) >= $signed(10'h000);
  assign \$3  = \$4  ? i : \$1 ;
  assign \$7  = ~ $signed(q);
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$5 ) begin end
    (* full_case = 32'd1 *)
    casez ({ \$17 , \$15 , \$13  })
      3'h7:
          phase = 3'h0;
      3'h6:
          phase = 3'h1;
      3'h4:
          phase = 3'h2;
      3'h5:
          phase = 3'h3;
      3'h1:
          phase = 3'h4;
      3'h0:
          phase = 3'h5;
      3'h2:
          phase = 3'h6;
      3'h3:
          phase = 3'h7;
    endcase
  end
endmodule

module phase_differentiator(rst, phase, out, valid, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$6  = 0;
  wire \$1 ;
  wire \$10 ;
  wire [10:0] \$12 ;
  wire [3:0] \$3 ;
  wire [3:0] \$4 ;
  wire [3:0] \$6 ;
  wire [3:0] \$7 ;
  wire [10:0] \$9 ;
  reg [2:0] _last_phase = 3'h0;
  wire [2:0] \_last_phase$next ;
  reg [9:0] _valid_counter = 10'h000;
  reg [9:0] \_valid_counter$next ;
  reg _valid_counter_reset;
  input clk;
  wire clk;
  output out;
  reg out = 1'h0;
  reg \out$next ;
  input [2:0] phase;
  wire [2:0] phase;
  input rst;
  wire rst;
  output valid;
  wire valid;
  assign \$10  = ~ valid;
  assign \$12  = _valid_counter + \$10 ;
  always @(posedge clk)
    _last_phase <= \_last_phase$next ;
  always @(posedge clk)
    out <= \out$next ;
  always @(posedge clk)
    _valid_counter <= \_valid_counter$next ;
  assign \$1  = _valid_counter == 10'h3ff;
  assign \$4  = phase - _last_phase;
  assign \$7  = phase - _last_phase;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$6 ) begin end
    (* full_case = 32'd1 *)
    casez (\$3 [2:0])
      3'h0:
          _valid_counter_reset = 1'h0;
      3'h7:
          _valid_counter_reset = 1'h0;
      3'h1:
          _valid_counter_reset = 1'h0;
      default:
          _valid_counter_reset = 1'h1;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$6 ) begin end
    \out$next  = out;
    casez (\$6 [2:0])
      3'h0:
          /* empty */;
      3'h7:
          \out$next  = 1'h1;
      3'h1:
          \out$next  = 1'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$6 ) begin end
    (* full_case = 32'd1 *)
    casez (_valid_counter_reset)
      1'h1:
          \_valid_counter$next  = 10'h000;
      default:
          \_valid_counter$next  = \$12 [9:0];
    endcase
  end
  assign \$3  = \$4 ;
  assign \$6  = \$7 ;
  assign \$9  = \$12 ;
  assign \_last_phase$next  = phase;
  assign valid = \$1 ;
endmodule

module q_filter(rst, in_, out, clk);
  wire [31:0] \$1 ;
  wire [3:0] \$10 ;
  wire [26:0] \$100 ;
  wire [3:0] \$102 ;
  wire [27:0] \$104 ;
  wire [3:0] \$106 ;
  wire [28:0] \$108 ;
  wire [1:0] \$110 ;
  wire [29:0] \$112 ;
  wire [1:0] \$114 ;
  wire [30:0] \$116 ;
  wire [1:0] \$118 ;
  wire [4:0] \$12 ;
  wire [31:0] \$120 ;
  wire [3:0] \$14 ;
  wire [5:0] \$16 ;
  wire [3:0] \$18 ;
  wire [1:0] \$2 ;
  wire [6:0] \$20 ;
  wire [3:0] \$22 ;
  wire [7:0] \$24 ;
  wire [7:0] \$26 ;
  wire [8:0] \$28 ;
  wire [7:0] \$30 ;
  wire [9:0] \$32 ;
  wire [7:0] \$34 ;
  wire [10:0] \$36 ;
  wire [7:0] \$38 ;
  wire [2:0] \$4 ;
  wire [11:0] \$40 ;
  wire [7:0] \$42 ;
  wire [12:0] \$44 ;
  wire [7:0] \$46 ;
  wire [13:0] \$48 ;
  wire [7:0] \$50 ;
  wire [14:0] \$52 ;
  wire [7:0] \$54 ;
  wire [15:0] \$56 ;
  wire [7:0] \$58 ;
  wire [1:0] \$6 ;
  wire [16:0] \$60 ;
  wire [7:0] \$62 ;
  wire [17:0] \$64 ;
  wire [7:0] \$66 ;
  wire [18:0] \$68 ;
  wire [7:0] \$70 ;
  wire [19:0] \$72 ;
  wire [7:0] \$74 ;
  wire [20:0] \$76 ;
  wire [7:0] \$78 ;
  wire [3:0] \$8 ;
  wire [21:0] \$80 ;
  wire [7:0] \$82 ;
  wire [22:0] \$84 ;
  wire [7:0] \$86 ;
  wire [23:0] \$88 ;
  wire [7:0] \$90 ;
  wire [24:0] \$92 ;
  wire [3:0] \$94 ;
  wire [25:0] \$96 ;
  wire [3:0] \$98 ;
  reg [29:0] _x = 30'h00000000;
  wire [29:0] \_x$next ;
  input clk;
  wire clk;
  input in_;
  wire in_;
  output [8:0] out;
  wire [8:0] out;
  input rst;
  wire rst;
  assign \$100  = \$96  + \$98 ;
  assign \$104  = \$100  + \$102 ;
  assign \$108  = \$104  + \$106 ;
  assign \$112  = \$108  + \$110 ;
  assign \$116  = \$112  + \$114 ;
  assign \$120  = \$116  + \$118 ;
  always @(posedge clk)
    _x <= \_x$next ;
  assign \$12  = \$8  + \$10 ;
  assign \$16  = \$12  + \$14 ;
  assign \$20  = \$16  + \$18 ;
  assign \$24  = \$20  + \$22 ;
  assign \$28  = \$24  + \$26 ;
  assign \$32  = \$28  + \$30 ;
  assign \$36  = \$32  + \$34 ;
  assign \$40  = \$36  + \$38 ;
  assign \$44  = \$40  + \$42 ;
  assign \$48  = \$44  + \$46 ;
  assign \$4  = in_ + \$2 ;
  assign \$52  = \$48  + \$50 ;
  assign \$56  = \$52  + \$54 ;
  assign \$60  = \$56  + \$58 ;
  assign \$64  = \$60  + \$62 ;
  assign \$68  = \$64  + \$66 ;
  assign \$72  = \$68  + \$70 ;
  assign \$76  = \$72  + \$74 ;
  assign \$80  = \$76  + \$78 ;
  assign \$84  = \$80  + \$82 ;
  assign \$88  = \$84  + \$86 ;
  assign \$8  = \$4  + \$6 ;
  assign \$92  = \$88  + \$90 ;
  assign \$96  = \$92  + \$94 ;
  assign \$1  = \$120 ;
  assign out = \$120 [8:0];
  assign \_x$next [29:1] = _x[28:0];
  assign \_x$next [0] = in_;
  assign \$2  = { 1'h0, _x[0] };
  assign \$6  = { _x[1], 1'h0 };
  assign \$10  = { 1'h0, _x[2], 2'h0 };
  assign \$14  = { 1'h0, _x[3], 2'h0 };
  assign \$18  = { _x[4], 3'h0 };
  assign \$22  = { _x[5], 3'h0 };
  assign \$26  = { 3'h0, _x[6], 4'h0 };
  assign \$30  = { 3'h0, _x[7], 4'h0 };
  assign \$34  = { 3'h0, _x[8], 4'h0 };
  assign \$38  = { 2'h0, _x[9], 5'h00 };
  assign \$42  = { 2'h0, _x[10], 5'h00 };
  assign \$46  = { 2'h0, _x[11], 5'h00 };
  assign \$50  = { 2'h0, _x[12], 5'h00 };
  assign \$54  = { 2'h0, _x[13], 5'h00 };
  assign \$58  = { 2'h0, _x[14], 5'h00 };
  assign \$62  = { 2'h0, _x[15], 5'h00 };
  assign \$66  = { 2'h0, _x[16], 5'h00 };
  assign \$70  = { 2'h0, _x[17], 5'h00 };
  assign \$74  = { 2'h0, _x[18], 5'h00 };
  assign \$78  = { 2'h0, _x[19], 5'h00 };
  assign \$82  = { 3'h0, _x[20], 4'h0 };
  assign \$86  = { 3'h0, _x[21], 4'h0 };
  assign \$90  = { 3'h0, _x[22], 4'h0 };
  assign \$94  = { _x[23], 3'h0 };
  assign \$98  = { _x[24], 3'h0 };
  assign \$102  = { 1'h0, _x[25], 2'h0 };
  assign \$106  = { 1'h0, _x[26], 2'h0 };
  assign \$110  = { _x[27], 1'h0 };
  assign \$114  = { 1'h0, _x[28] };
  assign \$118  = { 1'h0, _x[29] };
endmodule

module registers(rst, data_in, we, wg1_freq_mark, wg1_freq_space, wg2_freq, wg_mux_cfg, mixer_freq, frequency_invert, enforce_validity, enable_retimer, retimer_freq, retimer_width, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$7  = 0;
  wire \$1 ;
  wire \$11 ;
  wire \$13 ;
  wire \$15 ;
  wire \$17 ;
  wire \$19 ;
  wire \$3 ;
  wire \$5 ;
  wire \$7 ;
  wire \$9 ;
  input clk;
  wire clk;
  input [7:0] data_in;
  wire [7:0] data_in;
  output enable_retimer;
  reg enable_retimer = 1'h0;
  reg \enable_retimer$next ;
  output enforce_validity;
  reg enforce_validity = 1'h0;
  reg \enforce_validity$next ;
  output frequency_invert;
  reg frequency_invert = 1'h0;
  reg \frequency_invert$next ;
  output [7:0] mixer_freq;
  reg [7:0] mixer_freq = 8'h00;
  reg [7:0] \mixer_freq$next ;
  output [7:0] retimer_freq;
  reg [7:0] retimer_freq = 8'h00;
  reg [7:0] \retimer_freq$next ;
  output [1:0] retimer_width;
  reg [1:0] retimer_width = 2'h0;
  reg [1:0] \retimer_width$next ;
  input rst;
  wire rst;
  input [7:0] we;
  wire [7:0] we;
  output [7:0] wg1_freq_mark;
  reg [7:0] wg1_freq_mark = 8'h00;
  reg [7:0] \wg1_freq_mark$next ;
  output [7:0] wg1_freq_space;
  reg [7:0] wg1_freq_space = 8'h00;
  reg [7:0] \wg1_freq_space$next ;
  output [7:0] wg2_freq;
  reg [7:0] wg2_freq = 8'h00;
  reg [7:0] \wg2_freq$next ;
  output [1:0] wg_mux_cfg;
  reg [1:0] wg_mux_cfg = 2'h0;
  reg [1:0] \wg_mux_cfg$next ;
  assign \$9  = | we;
  assign \$11  = | we;
  assign \$13  = | we;
  assign \$15  = | we;
  assign \$17  = | we;
  assign \$1  = | we;
  assign \$19  = | we;
  always @(posedge clk)
    wg1_freq_space <= \wg1_freq_space$next ;
  always @(posedge clk)
    wg1_freq_mark <= \wg1_freq_mark$next ;
  always @(posedge clk)
    wg2_freq <= \wg2_freq$next ;
  always @(posedge clk)
    wg_mux_cfg <= \wg_mux_cfg$next ;
  always @(posedge clk)
    mixer_freq <= \mixer_freq$next ;
  always @(posedge clk)
    frequency_invert <= \frequency_invert$next ;
  always @(posedge clk)
    enforce_validity <= \enforce_validity$next ;
  always @(posedge clk)
    retimer_freq <= \retimer_freq$next ;
  always @(posedge clk)
    retimer_width <= \retimer_width$next ;
  always @(posedge clk)
    enable_retimer <= \enable_retimer$next ;
  assign \$3  = | we;
  assign \$5  = | we;
  assign \$7  = | we;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \wg1_freq_space$next  = wg1_freq_space;
    casez (\$1 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                \wg1_freq_space$next [3:0] = data_in[3:0];
            4'h1:
                \wg1_freq_space$next [7:4] = data_in[3:0];
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \wg1_freq_mark$next  = wg1_freq_mark;
    casez (\$3 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                /* empty */;
            4'h1:
                /* empty */;
            4'h2:
                \wg1_freq_mark$next [3:0] = data_in[3:0];
            4'h3:
                \wg1_freq_mark$next [7:4] = data_in[3:0];
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \wg2_freq$next  = wg2_freq;
    casez (\$5 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                /* empty */;
            4'h1:
                /* empty */;
            4'h2:
                /* empty */;
            4'h3:
                /* empty */;
            4'h4:
                \wg2_freq$next [3:0] = data_in[3:0];
            4'h5:
                \wg2_freq$next [7:4] = data_in[3:0];
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \wg_mux_cfg$next  = wg_mux_cfg;
    casez (\$7 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                /* empty */;
            4'h1:
                /* empty */;
            4'h2:
                /* empty */;
            4'h3:
                /* empty */;
            4'h4:
                /* empty */;
            4'h5:
                /* empty */;
            4'h6:
                \wg_mux_cfg$next  = data_in[1:0];
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \mixer_freq$next  = mixer_freq;
    casez (\$9 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                /* empty */;
            4'h1:
                /* empty */;
            4'h2:
                /* empty */;
            4'h3:
                /* empty */;
            4'h4:
                /* empty */;
            4'h5:
                /* empty */;
            4'h6:
                /* empty */;
            4'h7:
                \mixer_freq$next [3:0] = data_in[3:0];
            4'h8:
                \mixer_freq$next [7:4] = data_in[3:0];
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \frequency_invert$next  = frequency_invert;
    casez (\$11 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                /* empty */;
            4'h1:
                /* empty */;
            4'h2:
                /* empty */;
            4'h3:
                /* empty */;
            4'h4:
                /* empty */;
            4'h5:
                /* empty */;
            4'h6:
                /* empty */;
            4'h7:
                /* empty */;
            4'h8:
                /* empty */;
            4'h9:
                \frequency_invert$next  = data_in[0];
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \enforce_validity$next  = enforce_validity;
    casez (\$13 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                /* empty */;
            4'h1:
                /* empty */;
            4'h2:
                /* empty */;
            4'h3:
                /* empty */;
            4'h4:
                /* empty */;
            4'h5:
                /* empty */;
            4'h6:
                /* empty */;
            4'h7:
                /* empty */;
            4'h8:
                /* empty */;
            4'h9:
                \enforce_validity$next  = data_in[1];
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \retimer_freq$next  = retimer_freq;
    casez (\$15 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                /* empty */;
            4'h1:
                /* empty */;
            4'h2:
                /* empty */;
            4'h3:
                /* empty */;
            4'h4:
                /* empty */;
            4'h5:
                /* empty */;
            4'h6:
                /* empty */;
            4'h7:
                /* empty */;
            4'h8:
                /* empty */;
            4'h9:
                /* empty */;
            4'ha:
                \retimer_freq$next [3:0] = data_in[3:0];
            4'hb:
                \retimer_freq$next [7:4] = data_in[3:0];
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \retimer_width$next  = retimer_width;
    casez (\$17 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                /* empty */;
            4'h1:
                /* empty */;
            4'h2:
                /* empty */;
            4'h3:
                /* empty */;
            4'h4:
                /* empty */;
            4'h5:
                /* empty */;
            4'h6:
                /* empty */;
            4'h7:
                /* empty */;
            4'h8:
                /* empty */;
            4'h9:
                /* empty */;
            4'ha:
                /* empty */;
            4'hb:
                /* empty */;
            4'hc:
                \retimer_width$next  = data_in[1:0];
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$7 ) begin end
    \enable_retimer$next  = enable_retimer;
    casez (\$19 )
      1'h1:
          casez (data_in[7:4])
            4'h0:
                /* empty */;
            4'h1:
                /* empty */;
            4'h2:
                /* empty */;
            4'h3:
                /* empty */;
            4'h4:
                /* empty */;
            4'h5:
                /* empty */;
            4'h6:
                /* empty */;
            4'h7:
                /* empty */;
            4'h8:
                /* empty */;
            4'h9:
                /* empty */;
            4'ha:
                /* empty */;
            4'hb:
                /* empty */;
            4'hc:
                \enable_retimer$next  = data_in[3];
          endcase
    endcase
    casez (rst)
      1'h1:
          \enable_retimer$next  = 1'h0;
    endcase
  end
endmodule

module retimer_rx(rst, in_, frequency, width, data, we, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$8  = 0;
  wire \$1 ;
  wire \$11 ;
  wire [11:0] \$13 ;
  wire [10:0] \$14 ;
  wire [11:0] \$16 ;
  wire [9:0] \$18 ;
  wire [1:0] \$19 ;
  wire [9:0] \$21 ;
  wire [3:0] \$23 ;
  wire \$25 ;
  wire \$27 ;
  wire [3:0] \$29 ;
  wire [10:0] \$3 ;
  wire [3:0] \$30 ;
  wire \$32 ;
  wire \$34 ;
  wire [3:0] \$36 ;
  wire \$38 ;
  wire [10:0] \$4 ;
  wire [10:0] \$6 ;
  wire [10:0] \$7 ;
  wire [3:0] \$9 ;
  reg [2:0] _bit_index = 3'h0;
  reg [2:0] \_bit_index$next ;
  reg [9:0] _clock = 10'h000;
  reg [9:0] \_clock$next ;
  wire _clock_overflow;
  (* enum_base_type = "UARTState" *)
  (* enum_value_00 = "READY" *)
  (* enum_value_01 = "START" *)
  (* enum_value_10 = "DATA" *)
  (* enum_value_11 = "STOP" *)
  reg [1:0] _state = 2'h0;
  reg [1:0] \_state$next ;
  reg [8:0] _vote = 9'h000;
  reg [8:0] \_vote$next ;
  input clk;
  wire clk;
  output [7:0] data;
  reg [7:0] data = 8'h00;
  reg [7:0] \data$next ;
  wire edge_in_;
  wire edge_out;
  input [9:0] frequency;
  wire [9:0] frequency;
  input in_;
  wire in_;
  input rst;
  wire rst;
  output we;
  reg we = 1'h0;
  reg \we$next ;
  input [3:0] width;
  wire [3:0] width;
  assign \$9  = _bit_index + 1'h1;
  assign \$11  = \$9  == width;
  assign \$14  = _clock + frequency;
  assign \$16  = \$14  + 9'h100;
  assign \$1  = ~ in_;
  assign \$19  = in_ ? 2'h1 : 2'h3;
  assign \$21  = $signed(_vote) + $signed(\$19 );
  assign \$23  = _bit_index + 1'h1;
  assign \$25  = \$23  == width;
  assign \$27  = $signed(_vote) >= $signed(9'h000);
  assign \$30  = _bit_index + 1'h1;
  assign \$32  = $signed(_vote) < $signed(9'h000);
  assign \$34  = $signed(_vote) < $signed(9'h000);
  assign \$36  = _bit_index + 1'h1;
  assign \$38  = \$36  == width;
  always @(posedge clk)
    _clock <= \_clock$next ;
  always @(posedge clk)
    _vote <= \_vote$next ;
  always @(posedge clk)
    we <= \we$next ;
  always @(posedge clk)
    data <= \data$next ;
  always @(posedge clk)
    _bit_index <= \_bit_index$next ;
  always @(posedge clk)
    _state <= \_state$next ;
  assign \$4  = _clock + frequency;
  assign \$7  = _clock + frequency;
  \edge  \edge  (
    .clk(clk),
    .in_(edge_in_),
    .out(edge_out),
    .rst(rst)
  );
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$8 ) begin end
    \_clock$next  = \$7 [9:0];
    casez (_state)
      2'h0:
          casez (edge_out)
            1'h1:
                \_clock$next  = 10'h000;
          endcase
      2'h1:
          /* empty */;
      2'h2:
          casez (_clock_overflow)
            1'h1:
                casez (\$11 )
                  1'h1:
                      \_clock$next  = \$16 [9:0];
                endcase
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$8 ) begin end
    \_vote$next  = \$21 [8:0];
    casez (_clock_overflow)
      1'h1:
          \_vote$next  = 9'h000;
    endcase
    casez (_state)
      2'h0:
          casez (edge_out)
            1'h1:
                \_vote$next  = 9'h000;
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$8 ) begin end
    \we$next  = 1'h0;
    casez (_state)
      2'h0:
          /* empty */;
      2'h1:
          /* empty */;
      2'h2:
          casez (_clock_overflow)
            1'h1:
                casez (\$25 )
                  1'h1:
                      \we$next  = 1'h1;
                endcase
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$8 ) begin end
    \data$next  = data;
    casez (_clock_overflow)
      1'h1:
          \data$next  = { \$27 , data[7:1] };
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$8 ) begin end
    \_bit_index$next  = _bit_index;
    casez (_clock_overflow)
      1'h1:
          \_bit_index$next  = \$30 [2:0];
    endcase
    casez (_state)
      2'h0:
          /* empty */;
      2'h1:
          casez (_clock_overflow)
            1'h1:
                casez (\$32 )
                  1'h1:
                      \_bit_index$next  = 3'h0;
                endcase
          endcase
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$8 ) begin end
    \_state$next  = _state;
    (* full_case = 32'd1 *)
    casez (_state)
      2'h0:
          casez (edge_out)
            1'h1:
                \_state$next  = 2'h1;
          endcase
      2'h1:
          casez (_clock_overflow)
            1'h1:
                (* full_case = 32'd1 *)
                casez (\$34 )
                  1'h1:
                      \_state$next  = 2'h2;
                  default:
                      \_state$next  = 2'h0;
                endcase
          endcase
      2'h2:
          casez (_clock_overflow)
            1'h1:
                casez (\$38 )
                  1'h1:
                      \_state$next  = 2'h3;
                endcase
          endcase
      2'h3:
          casez (_clock_overflow)
            1'h1:
                \_state$next  = 2'h0;
          endcase
    endcase
    casez (rst)
      1'h1:
          \_state$next  = 2'h0;
    endcase
  end
  assign \$3  = \$4 ;
  assign \$6  = \$7 ;
  assign \$13  = \$16 ;
  assign \$18  = \$21 ;
  assign \$29  = \$30 ;
  assign _clock_overflow = \$4 [10];
  assign edge_in_ = \$1 ;
endmodule

module retimer_tx(rst, data, we, frequency, out, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$9  = 0;
  wire [10:0] \$1 ;
  wire \$10 ;
  wire [7:0] \$12 ;
  wire [10:0] \$2 ;
  wire [10:0] \$4 ;
  wire [10:0] \$5 ;
  wire [3:0] \$7 ;
  wire [3:0] \$8 ;
  reg [2:0] _bit_index = 3'h0;
  reg [2:0] \_bit_index$next ;
  reg [9:0] _clock = 10'h000;
  reg [9:0] \_clock$next ;
  wire _clock_overflow;
  reg [7:0] _data = 8'h00;
  reg [7:0] \_data$next ;
  (* enum_base_type = "UARTState" *)
  (* enum_value_00 = "READY" *)
  (* enum_value_01 = "START" *)
  (* enum_value_10 = "DATA" *)
  (* enum_value_11 = "STOP" *)
  reg [1:0] _state = 2'h0;
  reg [1:0] \_state$next ;
  input clk;
  wire clk;
  input [7:0] data;
  wire [7:0] data;
  input [9:0] frequency;
  wire [9:0] frequency;
  output out;
  reg out;
  input rst;
  wire rst;
  input we;
  wire we;
  assign \$10  = ! _bit_index;
  assign \$12  = + _data[7:1];
  always @(posedge clk)
    _clock <= \_clock$next ;
  always @(posedge clk)
    _bit_index <= \_bit_index$next ;
  always @(posedge clk)
    _state <= \_state$next ;
  always @(posedge clk)
    _data <= \_data$next ;
  assign \$2  = _clock + frequency;
  assign \$5  = _clock + frequency;
  assign \$8  = _bit_index + 1'h1;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$9 ) begin end
    \_clock$next  = \$5 [9:0];
    casez (we)
      1'h1:
          \_clock$next  = 10'h000;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$9 ) begin end
    \_bit_index$next  = _bit_index;
    casez (_clock_overflow)
      1'h1:
          \_bit_index$next  = \$8 [2:0];
    endcase
    casez (we)
      1'h1:
          \_bit_index$next  = 3'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$9 ) begin end
    out = 1'h0;
    casez (_state)
      2'h0:
          out = 1'h1;
      2'h1:
          out = 1'h0;
      2'h2:
          out = _data[0];
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$9 ) begin end
    \_state$next  = _state;
    casez (_state)
      2'h0:
          /* empty */;
      2'h1:
          casez (_clock_overflow)
            1'h1:
                \_state$next  = 2'h2;
          endcase
      2'h2:
          casez (_clock_overflow)
            1'h1:
                casez (\$10 )
                  1'h1:
                      \_state$next  = 2'h0;
                endcase
          endcase
    endcase
    casez (we)
      1'h1:
          \_state$next  = 2'h1;
    endcase
    casez (rst)
      1'h1:
          \_state$next  = 2'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$9 ) begin end
    \_data$next  = _data;
    casez (_state)
      2'h0:
          /* empty */;
      2'h1:
          /* empty */;
      2'h2:
          casez (_clock_overflow)
            1'h1:
                \_data$next  = \$12 ;
          endcase
    endcase
    casez (we)
      1'h1:
          \_data$next  = data;
    endcase
  end
  assign \$1  = \$2 ;
  assign \$4  = \$5 ;
  assign \$7  = \$8 ;
  assign _clock_overflow = \$2 [10];
endmodule

module rx(rst, in_, frequency, frequency_invert, out, valid, clk);
  wire [9:0] \$1 ;
  wire [9:0] \$3 ;
  wire \$5 ;
  input clk;
  wire clk;
  input [9:0] frequency;
  wire [9:0] frequency;
  input frequency_invert;
  wire frequency_invert;
  wire glitch_filter_in_;
  wire glitch_filter_out;
  wire i_filter_in_;
  wire [8:0] i_filter_out;
  input in_;
  wire in_;
  wire [9:0] mixer_frequency;
  wire mixer_i;
  wire mixer_in_;
  wire mixer_q;
  output out;
  wire out;
  wire [9:0] phase_detector_i;
  wire [2:0] phase_detector_phase;
  wire [9:0] phase_detector_q;
  wire phase_differentiator_out;
  wire [2:0] phase_differentiator_phase;
  wire phase_differentiator_valid;
  wire q_filter_in_;
  wire [8:0] q_filter_out;
  input rst;
  wire rst;
  output valid;
  wire valid;
  assign \$1  = i_filter_out - 8'hfc;
  assign \$3  = q_filter_out - 8'hfc;
  assign \$5  = glitch_filter_out ^ frequency_invert;
  glitch_filter glitch_filter (
    .clk(clk),
    .in_(glitch_filter_in_),
    .out(glitch_filter_out),
    .rst(rst)
  );
  i_filter i_filter (
    .clk(clk),
    .in_(i_filter_in_),
    .out(i_filter_out),
    .rst(rst)
  );
  mixer mixer (
    .clk(clk),
    .frequency(mixer_frequency),
    .i(mixer_i),
    .in_(mixer_in_),
    .q(mixer_q),
    .rst(rst)
  );
  phase_detector phase_detector (
    .i(phase_detector_i),
    .phase(phase_detector_phase),
    .q(phase_detector_q)
  );
  phase_differentiator phase_differentiator (
    .clk(clk),
    .out(phase_differentiator_out),
    .phase(phase_differentiator_phase),
    .rst(rst),
    .valid(phase_differentiator_valid)
  );
  q_filter q_filter (
    .clk(clk),
    .in_(q_filter_in_),
    .out(q_filter_out),
    .rst(rst)
  );
  assign valid = phase_differentiator_valid;
  assign out = \$5 ;
  assign glitch_filter_in_ = phase_differentiator_out;
  assign phase_differentiator_phase = phase_detector_phase;
  assign phase_detector_q = \$3 ;
  assign phase_detector_i = \$1 ;
  assign q_filter_in_ = mixer_q;
  assign i_filter_in_ = mixer_i;
  assign mixer_frequency = frequency;
  assign mixer_in_ = in_;
endmodule

module sck_edge(rst, in_, out, clk);
  wire \$1 ;
  wire \$3 ;
  input clk;
  wire clk;
  input in_;
  wire in_;
  reg last_in = 1'h0;
  wire \last_in$next ;
  output out;
  wire out;
  input rst;
  wire rst;
  assign \$1  = ~ last_in;
  assign \$3  = in_ & \$1 ;
  always @(posedge clk)
    last_in <= \last_in$next ;
  assign out = \$3 ;
  assign \last_in$next  = in_;
endmodule

module spi(rst, cs_n, sck, mosi, data, we, clk);
  reg \$auto$verilog_backend.cc:2083:dump_module$10  = 0;
  wire \$1 ;
  wire \$12 ;
  wire \$14 ;
  wire [9:0] \$16 ;
  wire [9:0] \$17 ;
  wire \$19 ;
  wire \$21 ;
  wire \$23 ;
  wire \$25 ;
  wire \$3 ;
  wire [3:0] \$5 ;
  wire [3:0] \$6 ;
  wire \$8 ;
  wire \$9 ;
  reg [2:0] _bit_index = 3'h0;
  reg [2:0] \_bit_index$next ;
  input clk;
  wire clk;
  input cs_n;
  wire cs_n;
  output [7:0] data;
  reg [7:0] data = 8'h00;
  reg [7:0] \data$next ;
  input mosi;
  wire mosi;
  input rst;
  wire rst;
  input sck;
  wire sck;
  wire sck_edge_in_;
  wire sck_edge_out;
  output we;
  reg we = 1'h0;
  wire \we$next ;
  assign \$9  = ~ cs_n;
  assign \$12  = ~ cs_n;
  assign \$14  = \$12  & sck_edge_out;
  assign \$17  = { data, 1'h0 } + mosi;
  assign \$1  = ~ cs_n;
  assign \$19  = ~ cs_n;
  assign \$21  = \$19  & sck_edge_out;
  assign \$23  = _bit_index == 3'h7;
  assign \$25  = \$21  & \$23 ;
  always @(posedge clk)
    _bit_index <= \_bit_index$next ;
  always @(posedge clk)
    data <= \data$next ;
  always @(posedge clk)
    we <= \we$next ;
  assign \$3  = \$1  & sck_edge_out;
  assign \$6  = _bit_index + 1'h1;
  sck_edge sck_edge (
    .clk(clk),
    .in_(sck_edge_in_),
    .out(sck_edge_out),
    .rst(rst)
  );
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$10 ) begin end
    \_bit_index$next  = _bit_index;
    casez (\$3 )
      1'h1:
          \_bit_index$next  = \$6 [2:0];
    endcase
    casez (\$8 )
      1'h1:
          \_bit_index$next  = 3'h0;
    endcase
  end
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$10 ) begin end
    \data$next  = data;
    casez (\$14 )
      1'h1:
          \data$next  = \$17 [7:0];
    endcase
  end
  assign \$5  = \$6 ;
  assign \$16  = \$17 ;
  assign \we$next  = \$25 ;
  assign sck_edge_in_ = sck;
  assign \$8  = cs_n;
endmodule

module wg1(rst, frequency, out, clk);
  wire [10:0] \$1 ;
  wire [10:0] \$2 ;
  reg [9:0] _state = 10'h000;
  wire [9:0] \_state$next ;
  input clk;
  wire clk;
  input [9:0] frequency;
  wire [9:0] frequency;
  wire [9:0] lut_in_;
  wire [9:0] lut_out;
  output [9:0] out;
  wire [9:0] out;
  input rst;
  wire rst;
  assign \$2  = _state + frequency;
  always @(posedge clk)
    _state <= \_state$next ;
  lut lut (
    .in_(lut_in_),
    .out(lut_out)
  );
  assign \$1  = \$2 ;
  assign \_state$next  = \$2 [9:0];
  assign out = lut_out;
  assign lut_in_ = _state;
endmodule

module wg2(rst, frequency, out, clk);
  wire [10:0] \$1 ;
  wire [10:0] \$2 ;
  reg [9:0] _state = 10'h000;
  wire [9:0] \_state$next ;
  input clk;
  wire clk;
  input [9:0] frequency;
  wire [9:0] frequency;
  wire [9:0] lut_in_;
  wire [9:0] lut_out;
  output [9:0] out;
  wire [9:0] out;
  input rst;
  wire rst;
  assign \$2  = _state + frequency;
  always @(posedge clk)
    _state <= \_state$next ;
  \lut$1  lut (
    .in_(lut_in_),
    .out(lut_out)
  );
  assign \$1  = \$2 ;
  assign \_state$next  = \$2 [9:0];
  assign out = lut_out;
  assign lut_in_ = _state;
endmodule

module wgmux(in2, cfg, out, in1);
  reg \$auto$verilog_backend.cc:2083:dump_module$11  = 0;
  wire [6:0] \$1 ;
  wire [6:0] \$2 ;
  wire [6:0] \$4 ;
  input [1:0] cfg;
  wire [1:0] cfg;
  input [5:0] in1;
  wire [5:0] in1;
  input [5:0] in2;
  wire [5:0] in2;
  output [5:0] out;
  reg [5:0] out;
  assign \$2  = in1 + in2;
  always @* begin
    if (\$auto$verilog_backend.cc:2083:dump_module$11 ) begin end
    out = 6'h00;
    casez (cfg)
      2'h0:
        begin
          out[4:0] = 5'h00;
          out[5] = 1'h1;
        end
      2'h1:
          out = in1;
      2'h2:
          out = \$4 [5:0];
    endcase
  end
  assign \$1  = \$4 ;
  assign \$4  = { 1'h0, \$2 [6:1] };
endmodule

